# 缓存替换算法实验报告

## 1. 实验目的

1. 实现并比较不同的缓存替换算法（LRU、LRU-K、LFU、CLOCK）
2. 分析不同算法在不同访问模式下的性能表现
3. 理解缓存替换算法的工作原理和适用场景

## 2. 实验环境

- 操作系统：Windows 10
- 编译器：g++ 11
- 编程语言：C++
- 测试数据：使用Zipf分布生成的访问序列

## 3. 算法实现

### 3.1 LRU (Least Recently Used)
- 使用双向链表和哈希表实现
- 最近使用的数据放在链表头部
- 最久未使用的数据在链表尾部
- 时间复杂度：O(1)

### 3.2 LRU-K
- 记录每个数据项的K次访问历史
- 使用第K次访问时间作为替换依据
- 实现复杂度较高，需要维护K次访问记录
- 时间复杂度：O(log K)

### 3.3 LFU (Least Frequently Used)
- 记录每个数据项的访问频率
- 替换访问频率最低的数据项
- 使用最小堆实现
- 时间复杂度：O(log n)

### 3.4 CLOCK
- 使用循环链表实现
- 每个数据项有一个引用位
- 通过时钟指针扫描，替换引用位为0的数据项
- 时间复杂度：O(1)

## 4. 实验设计

### 4.1 测试数据生成
- 使用Zipf分布生成访问序列
- 分布参数α = 1.2，模拟真实内存访问模式
- 测试规模：50, 100, 200, 500, 1000
- 键值范围：1-20
- 缓存容量：5

### 4.2 测试方法
- 对每个算法进行相同测试
- 记录缺页次数和缺页率
- 比较不同规模下的性能表现

## 5. 实验结果

### 5.1 缺页率比较
| 算法 | 50 | 100 | 200 | 500 | 1000 |
|------|-----|-----|-----|-----|------|
| LRU  |    |    |    |    |      |
| LRU-K|    |    |    |    |      |
| LFU  |    |    |    |    |      |
| CLOCK|    |    |    |    |      |

### 5.2 性能分析
1. **LRU算法**
   - 优点：实现简单，开销小
   - 缺点：对访问频率不敏感
   - 适用场景：短期局部性强的访问模式

2. **LRU-K算法**
   - 优点：考虑历史访问信息
   - 缺点：实现复杂，内存开销大
   - 适用场景：长期局部性强的访问模式

3. **LFU算法**
   - 优点：对访问频率敏感
   - 缺点：可能保留过期数据
   - 适用场景：访问频率稳定的场景

4. **CLOCK算法**
   - 优点：实现简单，开销小
   - 缺点：可能产生抖动
   - 适用场景：对性能要求不高的场景

## 6. 结论

1. 在Zipf分布（α=1.2）的访问模式下，LRU算法表现最好，这是因为：
   - 内存访问具有强短期局部性
   - LRU算法能很好地利用这种局部性
   - 实现简单，开销小

2. LRU-K算法虽然考虑了更多历史信息，但在实际测试中表现不如LRU，原因是：
   - 实现复杂度高
   - 内存开销大
   - 冷启动问题
   - 参数调优困难

3. 缓存替换算法的选择应该考虑：
   - 访问模式特征
   - 实现复杂度
   - 内存开销
   - 性能要求

## 7. 改进建议

1. 可以尝试其他访问模式（如均匀分布、高斯分布等）
2. 测试不同的缓存容量
3. 考虑实现更复杂的算法（如ARC、2Q等）
4. 添加更多性能指标（如命中率、访问延迟等）

## 8. 参考文献

1. "LRU-K Page Replacement Algorithm" by Elizabeth J. O'Neil et al.
2. "The CLOCK Page Replacement Algorithm" by Corbató
3. "Analysis of the PFF Page Replacement Algorithm" by P. J. Denning
4. "ARC: A Self-Tuning, Low Overhead Replacement Cache" by Nimrod Megiddo et al. 